\documentclass[a4paper,11pt]{article}
\usepackage{graphicx}
\usepackage{enumerate}

\begin{document}

\begin{flushright}

\vspace{1.1cm}

{\bf\Huge Problem Set 12}

\rule{0.25\linewidth}{0.5pt}

\vspace{0.5cm}
%Put Authors
Justin Ely
\linebreak
\newline
%Put Author's affiliations
\footnotesize{605.204.81.FA15 Computer Organization\\}
\vspace{0.5cm}
% Date here below
23 November, 2015
\end{flushright}

\noindent\rule{\linewidth}{1.0pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{1}

\begin{enumerate}
    \item Input
    \item Memory
    \item Datapath
    \item Control
    \item Output (given)
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{2}
\begin{enumerate}
    \item Data input
    \item Data output
    \item Data processing
    \item Data storage
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{3}
The correct answer is D) 32 bits.  MIPS machines have 32 32-bit registers.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{4}
The correct answer is C) 2's complement.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{5}
This statement is false.  Though there is a good deal of ambiguity to this question, compilers these days are written and optimized by very experienced developers to produce very efficient compiled code.  Though a specific program written directly in assembly by a highly skilled developer could be more efficient than it's high-level, compiled, equivalent, in general this is not the case.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{6}

The correct answer is B) Terabyte.  1 Terabtye is $10^{12}$ bytes.  This means $1,099,511,627,776$ bytes $* \frac{1 TB}{10^{12}  bytes} = 1.099$ TB $\sim$ 1 TB.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{7}
The correct answer is A) less than zero.  The binary representation of {\bf D49B} is 1101 0100 1001 1011.  The leading 1 in two's compliment arithmetic means that this value is less than zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section*{8}
\begin{itemize}
    \item Alan Turing: C) - computing theory
    \item Joseph Jacquard: D) - control program on punch cards
    \item J. Presper Eckert:  A) - ENIAC
    \item Vinton G. Cerf: B) -TCP/IP
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{9}
\begin{itemize}
    \item .text - Signifies to the assembler that the following section is assembly code.
    \item .asciiz - Stores the following should be stored in memory as a null-terminated string.
    \item .word - Stores the following values as words in memory
    \item .globl - Tells the assembler that the following label is considered global and is able to be referenced from other files
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{10}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{11}
The {\bf PROLOG} code exists to save the state of the registers before a subroutine call so that data isn't lost.  The end code to restore registers back to their initial state is called the {\bf EPILOG}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{12}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{13}
The correct answer is {\bf C)}, assign machine memory addresses to symbol labels.  Though A) and B) are beneficial for many reasons, they are not required by all compilers.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{14}
\begin{itemize}
  \item A) {\bf Addition of two positive numbers will never overflow.}  This statement is false.  An easy example would be to add the largest possible integer to the largest possible integer of a given precision.  This result is too large, and overflow will occur.
  \item B) {\bf Addition of a positive and a negative number will never overflow.}  This statement is true.  The largest positive integer added to the largest negative number can be, at most, 0.  Thus, this situation can never underflow.
  \item C) {\bf Multiplication of a positive and negative number will never overflow.}  This statement is false.  The resulting value can be incredibly large, and outside the allowable number range on either the positive or negative side.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{15}
The main reason a two-pass assembler is necessary is because, {\bf C)}, symbols may be used as operands before they are defined.  If this happens, a one-pass assembler will not be able to resolve the symbol when it's first used. 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{16}
Overflow is when the result of a computation is too large to fit in the available registers. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{17}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{18}
The BGE pseudo instruction requires two individual MIPS instructions:
\begin{verbatim}
slt $t0, $t6, $s3
beq $t0, $zero, FINISH 
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{19}
The MIPS language has to subtract immediate because the add immediate instruction can be used with a negative value to achieve the same result.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{20}
\begin{itemize}
  \item {\bf Register: } jr
  \item {\bf Base: } lw
  \item {\bf Program Counter: } beq
  \item {\bf Immediate: } addi
  \item {\bf Pseudo Direct:}  j
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{21}

\begin{enumerate}
  \item Normalization is the standard representation of exponential numbers
  \item It allows the simplification of the algorithms and hardware
  \item It allows for higher accuracy in the represented values
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{22}
The first "killer app" was email.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{23}
0's in every bit represents exactly 0 in IEEE 754 format.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{24}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{25}
\begin{itemize}
  \item {\bf Translate mnemonic operation codes to machine codes} is performed in pass two.
  \item {\bf Save addresses assigned to labels} is performed in pass one. 
  \item {\bf Scan for label definitions} is performed in pass one.
  \item {\bf Write object file} is performed in pass two.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{26}
\begin{itemize}
  \item a) Object instruction code. {\bf Text Segment}
  \item b) Relative address of global symbol.  {\bf Relocation}
  \item c) Modification information. {\bf Symbol}
  \item d) Program name.  {\bf Header}  
  \item e) Data values. {\bf Data Segment}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{27}
No, MIPS only uses 32 bit operands.  (Check initial lectures)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{28}
This statement is false.  Natrual languages are ambiguous and verbose, which make them very unsuitable to use as programming languages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{29}
This statement is true.  While a mouse with a track ball doesn't require an embedded processor, an optical mouse does require an embedded processor to perform real-time computation of the optical image. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{30}
\begin{itemize}
  \item Guard Bit:  is the first bit past the truncated mantissa, and is used to keep higher precision after the operands have been aligned.
  \item Round Bit: is the second bit past the truncated mantissa, and is used to keep higher precision after the operands have been aligned.
  \item Sticky Bit: is the third bit past the truncated mantissa, and is used as an indication of bits past it.
  \item NaN: is a reserved binary representation that means Not a Number.  This value is used as the result of invalid operations such as the square root of a negative number.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{31}
RAID stands for Redundant Array of Inexpensive Disks and is an umbrella term for a selection of strategies that provide increased data security and performance through redundancy.  RAID 1 is a specific strategy that writes data to two or more hard drives simultaneously.  This way, read requests can be handled by any available drive, and no data is lost through the failure of a single disk (or multiple, given the total number of copies).
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{32}
The correct answer is C) Supports the operation of a specific computer.  System Software includes thinks like the OS and hardware drivers that interface with specific hardware.  Though it can be translated to many machines of different architectures, it is not innately machine independent.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{33}
Booth's algorithm is a technique for multiplying two's compliment integers that increases efficiency in most cases, though it is not universally more efficient.  The algorithm takes advantage of rows of repeated 1's or 0's where only a bit shift is needed instead of multiple additions.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{34}
This statement is True.  An example of a blocked program is one that is waiting for a memory resource that another program is actively using.  Once the other program releases the memory, then the blocked program can resume.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{35}
In this situation, program  Lecture 13b

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{36}
\begin{itemize}
  \item A) One priority scheme is First-Come-First-Served (FCFS).  In this scheme, each process is immediately added in to the queue.  The queue is processed sequentially, where the process that has waited the longest is always the next to execute.  This scheme doesn't take any other criteria into account, such as program execution time or memory usage.
  \item B) Another priority scheme is Round-Robin.  This scheme gives each running process a set amount of time before a context switch occurs.  This scheme also doesn't take into account any other criteria such as individual program execution time or memory usage.  This strategy favors short-running programs.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{37}
The Grammar describes the {\bf (B) SYNTAX} of the programming language.  The Semantics, on the other hand, is the higher-level meaning of the individual statements.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{38}
This statement is False.  The I/O channel would cause an interrupt when the I/O process is requested and started, and would return from the interrupt when the process in completed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{39}
The correct answer is C).   The main purpose of Interrupts is to allow more efficient processing of multiple concurrent tasks.  A simple example would be trying to type in the terminal while a computation algorithm is executing.  Without interrupts to process the keystrokes, and input would need to wait until the, potentially long, running programs finishes executing. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{40}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{41}
The other main task is to provide the user-interface to the computer.  This makes the computer much more friendly and easy to use by providing an abstraction to the actual hardware.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{42}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{43}
\begin{itemize}
  \item {\bf SCANNER:}  The scanner parses through the source program and identifies the tokens. 
  \item {\bf PARSER:} The parser builds the parse tree for the program.  This can use the bottom-up or top-down approach.
  \item {\bf CODE GENERATOR:} The code generator takes the parse tree and generates quadruples of the program code.  These quadrules help later optimization and generation of machine/assembly code.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section*{44}
The major flaw with BGP is that it automatically trusts users.  Data packets can be sent and received by anyone, with no encryption and no user verification.  This makes the information sent on the internet very insecure, where the only real protection from malicious eavesdropping is the sheer volume of information to process.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{45}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{46}
\begin{enumerate}
  \item Channel Program: D) Set of instructions for special i/o.
  \item Context Switching: G) Saving/restoring registers by Interrupt Processor.
  \item Dead-Lock:  A) Set of programs in a Circular Wait.
  \item Dispatching:  E) Select next program to process by CPU.
  \item Storage Protection Key:  H) Half byte used for memory access control.
  \item Inhibit Interrupt:  B) Set mase to prevent Interrupt Processing.
  \item Page table map:  F) Data area used by the Memory Manager.
  \item Program status word:  C) Register containing interrupt mask.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{47}
The Timer Interrupt often has a lower priority than the Operating System Service Request (OSSR) because a direct request from the OS often cannot wait for a program to finish.  The Timer Interrupt is part of program scheduling, where programs are only allowed to run for a certain time before a context switch happens and another program is loaded.  If the OSSR had a lower priority than the Timer, then an OS request could only execute in-between running programs.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{48}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{49}
\begin{itemize}
  \item A) The OS can abort all deadlock processes.  This will resolve the deadlock situation, and when the programs are restarted there should be enough of a difference in start time to avoid the same deadlock on the next run.  
  \item B) The OS can successively abort deadlocked processes until the deadlock is resolved.  This terminates some programs and leaves others running, but eliminates fewer running jobs that shutting down all-offending jobs.  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{50}
\begin{itemize}
  \item First, the OS must store all register values so that the currently running program can proceed once the interrupt has been processed.
  \item Second, the OS mush transfer control to the interrupt handler.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{51}
No, it is never safe for a MIPS user program to use the {\bf \$k0 or \$k1} registers.  These two registers are reserved, by convention, for the OS to use in the event of an exception.  All other registers are saved and restored when control is given back to the program, but the data in these two registers could be lost or changed at any time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{52}
Assembly Languages should be avoided for general application development because they don't contain sufficient abstraction for most problems.  Assembly languages are very close to the machines and require explicit handling of every register to perform any operation.  This process requires a great deal of effort and is prone to human error.  Additionally, the built-in instruction set is incredibly limited when compared to a high-level programming language.  This makes the computation of most common tasks very time-consuming and costly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{53}
Module 10A

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{54}

\begin{tabular}{ | c | c | r | r | r |}
  \hline
    LC & Operation & Op1 & Op2 & Result  \\ \hline
    (1) & * & \#3 & EX & i1 \\ \hline
    (2) & * & \#5 & WHY & i2 \\ \hline
    (3) & * & EX & WHY & i3 \\ \hline
    (4) & + & i1 & i2 & 41 \\ \hline
    (5) & + & i3 & i4 & i5 \\ \hline
    (6) & := & i5 &  & ZEE \\ \hline
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{55}
Module 13 lecture D.
\begin{enumerate}
  \item  Access Control
  \item  Information flow control
  \item  Certification
  \item  Secure building
  \item  Encryption
  \item
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{56}
Yes, I did complete the online Course Evaluation Survey.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
